<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta charset="utf-8"><meta name="title" content="Posts about Scala | Corleonis"><meta name="description" content="I am Swind."><meta name="author" content="Swind"><title>Posts about Scala | Corleonis</title><!-- Le styles --><link href="../assets/css/bootstrap.css" rel="stylesheet" type="text/css"><link href="../assets/css/rst.css" rel="stylesheet" type="text/css"><link href="../assets/css/monokai.css" rel="stylesheet" type="text/css"><link href="../assets/css/colorbox.css" rel="stylesheet" type="text/css"><link href="../assets/css/slides.css" rel="stylesheet" type="text/css"><link href="../assets/css/theme.css" rel="stylesheet" type="text/css"><link href="../assets/css/bootstrap-responsive.css" rel="stylesheet" type="text/css"><script src="../assets/js/jquery-1.7.2.min.js" type="text/javascript"></script><script src="../assets/js/jquery.colorbox-min.js" type="text/javascript"></script><script src="../assets/js/slides.min.jquery.js" type="text/javascript"></script><script src="../assets/js/bootstrap.min.js" type="text/javascript"></script><!-- Le HTML5 shim, for IE6-8 support of HTML5 elements --><!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script>
    <![endif]--><link rel="alternate" type="application/rss+xml" title="RSS for tag Scala (en)" href="scala.xml"></head><body>
<!-- Menubar -->
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <div class="container">
        
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
        </a>        
        
            <a class="brand" href="../">
            Corleonis
            </a>
            <!-- Everything you want hidden at 940px or less, place within here -->
            <div class="nav-collapse collapse">
                <ul class="nav"><li><a href="../archive.html">Archives</a>
            </li><li><a href="index.html">Tags</a>
            </li><li><a href="../stories/linux-note.html">Linux 筆記</a>

                </li></ul><ul class="nav pull-right"></ul></div>
        </div>
    </div>
</div>
<!-- End of Menubar -->
<div class="container-fluid" id="container-fluid">
    <!--Body content-->
    <div class="row-fluid">
    <div class="span2"></div>
    <div class="span8">
    
        <div class="postbox">
        <h1><a href="../posts/build-restful-api-server-by-spray.html">用 Spray 建立一個簡單的 RESTful API Server</a>
        <small>  
             Posted: 2012-11-06 20:11
        </small></h1>
        <hr><div><div class="section" id="spray">
<h2>Spray</h2>
<p><a class="reference external" href="http://spray.cc/">Spray</a></p>
<p>最初是想要建立一個提供查詢服務的 RESTful API Server，可以讓 Client 的應用程式透過 RESTful API 查詢一些資料。
但是看來看去，用 Play2、Jersey、RESTEasy 等都蠻麻煩的，而且還需要使用 Web container（像 Tomcat、Jetty 等）。
所以才找到這個 Spray，而且又是用 Scala 開發的，實在沒有理由不試試看阿。 XD</p>
<p>若你連到官網看會發現他分成很多模組，老實說我也沒有詳細研究每個模組的功能。
因為 <a class="reference external" href="http://spray.cc/documentation/spray-can/">spray-can</a> 的範例看起來最簡單並且也符合我的需求，所以就直接用他了。</p>
<p>想瞭解更詳細內容的可以參考 <a class="reference external" href="https://github.com/spray/spray/tree/release-1.0-M2/examples/spray-can/simple-http-server/">spray-can 範例文件</a> 與 <a class="reference external" href="http://blog.cloudfoundry.com/2012/05/11/running-standalone-web-applications-on-cloud-foundry/">Running Standalone Web Applications on Cloud Foundry</a></p>
</div>
<div class="section" id="id1">
<h2>環境準備</h2>
<p><a class="reference external" href="https://github.com/spray/spray/tree/release-1.0-M2/examples/spray-can/">spray-can 的範例</a> 已經有建立好一個簡單的 HttpServer 了，
所以我們先將 Spray 從 Github 上 Clone 下來。</p>
<pre class="code bash literal-block">
git clone git://github.com/spray/spray.git
</pre>
<p>然後複製出 spray/examples/spray-can/simple-http-server。
接著在 simple-http-server 底下，建立 build.sbt 讓 SBT 去 include 所需要的 Library。</p>
<p>順便設定 <a class="reference external" href="https://github.com/twitter/sbt-package-dist">package-dist</a>  這個 sbt plugin 所需要的資料。
package-dist 可以協助我們將 Project 所需要的 Library 與程式本身全部打包成一個 zip 檔。
但是這個 plugin 只能使用在 sbt 0.11.x，目前我還沒有看到可以在 0.12.x 的版本。
如果你不想用的話可以拿掉 Start 到 End 中間的內容。</p>
<p>而最下面的</p>
<blockquote>
EclipseKeys.createSrc := EclipseCreateSrc.Default + EclipsCreateSrc.Resource</blockquote>
<p>則是針對 sbteclipse 做的設定，讓 plugin 在產生 eclipse project 的時候可以將 src/main/resources 也加入 source folder。</p>
<pre class="code scala literal-block">
<span class="c1">//Start - For package-dist
</span><span class="k">import</span> <span class="nn">com.twitter.sbt._</span>

<span class="n">seq</span><span class="o">(</span><span class="nc">PackageDist</span><span class="o">.</span><span class="n">newSettings</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span>

<span class="n">seq</span><span class="o">(</span><span class="nc">GitProject</span><span class="o">.</span><span class="n">gitSettings</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span>

<span class="n">packageDistZipName</span> <span class="o">:=</span> <span class="s">"DictionaryServer.zip"</span>
<span class="c1">//End - For package-dist
</span>
<span class="n">organization</span> <span class="o">:=</span> <span class="s">"cc.spray"</span>

<span class="n">name</span> <span class="o">:=</span> <span class="s">"DictionaryServer"</span>

<span class="n">mainClass</span> <span class="n">in</span> <span class="o">(</span><span class="nc">Compile</span><span class="o">,</span> <span class="n">packageBin</span><span class="o">)</span> <span class="o">:=</span> <span class="nc">Some</span><span class="o">(</span><span class="s">"cc.spray.example.Main"</span><span class="o">)</span>

<span class="n">version</span> <span class="o">:=</span> <span class="s">"0.1.0-SNAPSHOT"</span>

<span class="n">scalaVersion</span> <span class="o">:=</span> <span class="s">"2.9.2"</span>

<span class="n">resolvers</span> <span class="o">++=</span> <span class="nc">Seq</span><span class="o">(</span>
<span class="s">"Typesafe repo"</span> <span class="n">at</span> <span class="s">"http://repo.typesafe.com/typesafe/releases/"</span><span class="o">,</span>
<span class="s">"spray repo"</span> <span class="n">at</span> <span class="s">"http://repo.spray.cc/"</span>
<span class="o">)</span>

<span class="n">libraryDependencies</span> <span class="o">++=</span> <span class="nc">Seq</span><span class="o">(</span>
    <span class="s">"com.typesafe.akka"</span> <span class="o">%</span> <span class="s">"akka-actor"</span> <span class="o">%</span> <span class="s">"2.0.3"</span><span class="o">,</span>
    <span class="s">"cc.spray"</span> <span class="o">%</span> <span class="s">"spray-server"</span> <span class="o">%</span> <span class="s">"1.0-M2"</span><span class="o">,</span>
    <span class="s">"cc.spray"</span> <span class="o">%</span> <span class="s">"spray-can"</span> <span class="o">%</span> <span class="s">"1.0-M2"</span><span class="o">,</span>
    <span class="s">"org.slf4j"</span> <span class="o">%</span> <span class="s">"slf4j-api"</span> <span class="o">%</span> <span class="s">"1.6.6"</span><span class="o">,</span>
    <span class="s">"ch.qos.logback"</span> <span class="o">%</span> <span class="s">"logback-classic"</span> <span class="o">%</span> <span class="s">"1.0.7"</span>
<span class="o">)</span>

<span class="c1">//sbteclipse setting
</span><span class="nc">EclipseKeys</span><span class="o">.</span><span class="n">createSrc</span> <span class="o">:=</span> <span class="nc">EclipseCreateSrc</span><span class="o">.</span><span class="nc">Default</span> <span class="o">+</span> <span class="nc">EclipseCreateSrc</span><span class="o">.</span><span class="nc">Resource</span>
</pre>
<p>這邊注意一下 Spray 的版本問題，現在最新的 Example 程式碼是針對最新版本的 spray，但他們還沒有正式 release，
並且他們還換了 package name 等，所以我都是使用 1.0-M2 的版本，當然 Library 也是使用 1.0-M2。</p>
<p>到這邊，我們的環境就準備的差不多了。接下來，只要執行範例程式碼就可以有一個可以提供 Web Service 的 Http Server 了。</p>
</div>
<div class="section" id="start-http-server">
<h2>Start Http Server</h2>
<p>如果你對於 Akka 的用法有一點概念的話，那麼 Spray 對你來說應該是非常好上手的。</p>
<p>Main.scala 啟動一個 IoWorker Actor 負責 low-level 的 network I/O，
接下來將 IoWorker Actor 以及 Service Actor 傳入 HttpServer Actor並啟動 Http Server。
之後透過發送一個 HttpServer.Bind 的 Message 給 Server 設定 IP 與 Port。
這樣就完成了 Server 的啟動與設定了。</p>
<pre class="code scala literal-block">
<span class="c1">// we need an ActorSystem to host our application in
</span><span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">"SimpleHttpServer"</span><span class="o">)</span>

<span class="c1">// the handler actor replies to incoming HttpRequests
</span><span class="k">val</span> <span class="n">handler</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">TestService</span><span class="o">])</span>

<span class="c1">// every spray-can HttpServer (and HttpClient) needs an IoWorker for low-level network IO
// (but several servers and/or clients can share one)
</span><span class="k">val</span> <span class="n">ioWorker</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">IoWorker</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">start</span><span class="o">()</span>

<span class="c1">// create and start the spray-can HttpServer, telling it that we want requests to be
// handled by our singleton handler
</span><span class="k">val</span> <span class="n">server</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span>
<span class="n">props</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">HttpServer</span><span class="o">(</span><span class="n">ioWorker</span><span class="o">,</span> <span class="nc">MessageHandlerDispatch</span><span class="o">.</span><span class="nc">SingletonHandler</span><span class="o">(</span><span class="n">handler</span><span class="o">))),</span>
<span class="n">name</span> <span class="k">=</span> <span class="s">"http-server"</span>
<span class="o">)</span>

<span class="c1">// a running HttpServer can be bound, unbound and rebound
// initially to need to tell it where to bind to
</span><span class="n">server</span> <span class="o">!</span> <span class="nc">HttpServer</span><span class="o">.</span><span class="nc">Bind</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">,</span> <span class="mi">8080</span><span class="o">)</span>

<span class="c1">// finally we drop the main thread but hook the shutdown of
// our IoWorker into the shutdown of the applications ActorSystem
</span><span class="n">system</span><span class="o">.</span><span class="n">registerOnTermination</span> <span class="o">{</span>
<span class="n">ioWorker</span><span class="o">.</span><span class="n">stop</span><span class="o">()</span>
<span class="o">}</span>
</pre>
</div>
<div class="section" id="service">
<h2>提供 Service</h2>
<div class="section" id="http-request">
<h3>處理 Http Request</h3>
<p>提供 Service 的 Actor 會接收到 HttpRequest 的 Message，HttpRequest 的內容如下。</p>
<pre class="code scala literal-block">
<span class="k">case</span> <span class="k">class</span> <span class="nc">HttpRequest</span><span class="o">(</span>
            <span class="n">method</span>   <span class="k">:</span> <span class="kt">HttpMethod</span> <span class="o">=</span> <span class="nc">HttpMethods</span><span class="o">.</span><span class="nc">GET</span><span class="o">,</span>
            <span class="n">uri</span>      <span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"/"</span><span class="o">,</span>
            <span class="n">headers</span>  <span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">HttpHeader</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Nil</span><span class="o">,</span>
            <span class="n">content</span>  <span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">HttpContent</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span><span class="o">,</span>
            <span class="n">protocol</span> <span class="k">:</span> <span class="kt">HttpProtocol</span> <span class="o">=</span> <span class="n">`HTTP/1.1`</span><span class="o">)</span>
</pre>
<p>然後就可以利用 match 來處理各種不同的 HttpRequest，
例如有連線到 <a class="reference external" href="http://localhost:8080/">http://localhost:8080/</a> 的 GET 請求，
就會對應到第一個 HttpRequest "/"。</p>
<pre class="code scala literal-block">
<span class="k">protected</span> <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>

    <span class="k">case</span> <span class="nc">HttpRequest</span><span class="o">(</span><span class="nc">GET</span><span class="o">,</span> <span class="s">"/"</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="n">sender</span> <span class="o">!</span> <span class="n">index</span>

    <span class="k">case</span> <span class="nc">HttpRequest</span><span class="o">(</span><span class="nc">GET</span><span class="o">,</span> <span class="s">"/ping"</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="n">sender</span> <span class="o">!</span> <span class="n">response</span><span class="o">(</span><span class="s">"PONG!"</span><span class="o">)</span>

    <span class="k">case</span> <span class="nc">HttpRequest</span><span class="o">(</span><span class="nc">GET</span><span class="o">,</span> <span class="s">"/stats"</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="k">val</span> <span class="n">client</span> <span class="k">=</span> <span class="n">sender</span>
        <span class="n">context</span><span class="o">.</span><span class="n">actorFor</span><span class="o">(</span><span class="s">"../http-server"</span><span class="o">).</span><span class="n">ask</span><span class="o">(</span><span class="nc">HttpServer</span><span class="o">.</span><span class="nc">GetStats</span><span class="o">)(</span><span class="mf">1.</span><span class="n">second</span><span class="o">).</span><span class="n">onSuccess</span> <span class="o">{</span>

    <span class="k">case</span> <span class="n">x</span><span class="k">:</span> <span class="kt">HttpServer.Stats</span> <span class="o">=&gt;</span> <span class="n">client</span> <span class="o">!</span> <span class="n">statsPresentation</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="o">}</span>
</pre>
</div>
<div class="section" id="http-response">
<h3>建立 Http Response</h3>
<p>Response 的內容也非常好設定，以剛剛送回 sender 的 index 為例子，
Spray 使用一個 HttpResonse 的 case class 來代表 Response 的內容。
只要設定好 headers、body 與 status 就可以傳送回去 Sender 了。</p>
<pre class="code scala literal-block">
<span class="k">lazy</span> <span class="k">val</span> <span class="n">index</span> <span class="k">=</span> <span class="nc">HttpResponse</span><span class="o">(</span>
<span class="n">headers</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">HttpHeader</span><span class="o">(</span><span class="s">"Content-Type"</span><span class="o">,</span> <span class="s">"text/html"</span><span class="o">)),</span>
<span class="n">body</span> <span class="k">=</span>
  <span class="o">&lt;</span><span class="n">html</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">body</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="nc">Say</span> <span class="n">hello</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="n">spray</span><span class="o">-</span><span class="n">can</span><span class="o">&lt;/</span><span class="n">i</span><span class="o">&gt;!&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="nc">Defined</span> <span class="n">resources</span><span class="o">:&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">"/ping"</span><span class="o">&gt;/</span><span class="n">ping</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">"/search"</span><span class="o">&gt;/</span><span class="n">search</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">"/stats"</span><span class="o">&gt;/</span><span class="n">stats</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">"/crash"</span><span class="o">&gt;/</span><span class="n">crash</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">"/timeout"</span><span class="o">&gt;/</span><span class="n">timeout</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">"/timeout/timeout"</span><span class="o">&gt;/</span><span class="n">timeout</span><span class="o">/</span><span class="n">timeout</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">"/stop"</span><span class="o">&gt;/</span><span class="n">stop</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
      <span class="o">&lt;/</span><span class="n">ul</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">body</span><span class="o">&gt;</span>
  <span class="o">&lt;/</span><span class="n">html</span><span class="o">&gt;.</span><span class="n">toString</span><span class="o">.</span><span class="n">getBytes</span><span class="o">(</span><span class="s">"ISO-8859-1"</span><span class="o">),</span>
<span class="n">status</span> <span class="k">=</span> <span class="mi">200</span><span class="o">)</span>
</pre>
</div>
</div></div>
        
    <p>
        <a href="../posts/build-restful-api-server-by-spray.html#disqus_thread" data-disqus-identifier="cache\posts\2012-11-06-spray.html">Comments</a>

        </p></div>
        <div class="postbox">
        <h1><a href="../posts/akka-2_0-note-6.html">Akka 2.0 筆記(6) - Dispatcher 的設定</a>
        <small>  
             Posted: 2012-06-17 20:19
        </small></h1>
        <hr><div><p>今天早上先簡單了依照昨天畫得架構圖做了一個雛型，整個跑起來功能是以了，但是流程整個悲劇 Orz ...
先是 Exception Handling 做的不夠好，結果就真的是 "Let it Crash" 一直死一直死一直死，好像在玩 D3 的煉獄模式一樣。</p>
<p>再來是我沒有去設定 Dispatcher 所以 Thread 用了十幾個。如果我沒有看錯的話，依照 Akka <a class="reference external" href="https://github.com/akka/akka/blob/master/akka-actor/src/main/resources/reference.conf">reference.conf</a> 的設定，
Default Dispatcher 使用 fork-join-executor，他的預設設定如下</p>
<pre class="code scala literal-block">
<span class="n">fork</span><span class="o">-</span><span class="n">join</span><span class="o">-</span><span class="n">executor</span> <span class="o">{</span>
  <span class="k">#</span> <span class="nc">Min</span> <span class="n">number</span> <span class="n">of</span> <span class="n">threads</span> <span class="n">to</span> <span class="n">cap</span> <span class="n">factor</span><span class="o">-</span><span class="n">based</span> <span class="n">parallelism</span> <span class="n">number</span> <span class="n">to</span>
  <span class="n">parallelism</span><span class="o">-</span><span class="n">min</span> <span class="k">=</span> <span class="mi">8</span>

  <span class="k">#</span> <span class="nc">Parallelism</span> <span class="o">(</span><span class="n">threads</span><span class="o">)</span> <span class="o">...</span> <span class="n">ceil</span><span class="o">(</span><span class="n">available</span> <span class="n">processors</span> <span class="o">*</span> <span class="n">factor</span><span class="o">)</span>
  <span class="n">parallelism</span><span class="o">-</span><span class="n">factor</span> <span class="k">=</span> <span class="mf">3.0</span>

  <span class="k">#</span> <span class="nc">Max</span> <span class="n">number</span> <span class="n">of</span> <span class="n">threads</span> <span class="n">to</span> <span class="n">cap</span> <span class="n">factor</span><span class="o">-</span><span class="n">based</span> <span class="n">parallelism</span> <span class="n">number</span> <span class="n">to</span>
  <span class="n">parallelism</span><span class="o">-</span><span class="n">max</span> <span class="k">=</span> <span class="mi">64</span>
<span class="o">}</span>
</pre>
<p>很簡單的 parallelism-min 與 parallelism-max 的值代表著 Thread 的上下限，那麼 parallelism_factor 呢？</p>
<p>他同樣也是限制 Thread 的上限，上限的計算方式為</p>
<blockquote>
parallelism-factor * 你的處理器核心數</blockquote>
<p>所以我的四核心桌機使用這個 Dispatcher 最多會開到 12 個 Thread Orz ...</p>
<p>難怪我的 Thread 會滿天飛了</p>
<p>這邊我要先搞定我之前一直逃避的 Akka 設定檔，之前會逃避是因為我用 Eclipse 的 ScalaIDE 加上 sbt 來開發。
不知道為什麼之前設定檔在 build 的時候一直不會自動放到編譯完成的目錄下面，所以就整個怒完全不想搞設定檔這種東西。
那時候是偷懶直接寫在程式碼裡面。</p>
<pre class="code scala literal-block">
<span class="k">val</span> <span class="n">config</span> <span class="k">=</span> <span class="s">"""
   my-dispatcher {
     # Dispatcher is the name of the event-based dispatcher
     type = Dispatcher
     # What kind of ExecutionService to use
     executor = "fork-join-executor"
     # Configuration for the fork join pool
     fork-join-executor {
       # Min number of threads to cap factor-based parallelism number to
       parallelism-min = 2
       # Parallelism (threads) ... ceil(available processors * factor)
       parallelism-factor = 2.0
       # Max number of threads to cap factor-based parallelism number to
       parallelism-max = 10
     }
     # Throughput defines the maximum number of messages to be
     # processed per actor before the thread jumps to the next actor.
     # Set to 1 for as fair as possible.
     throughput = 1
   }
   """</span>
<span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">"MySystem"</span><span class="o">,</span><span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">load</span><span class="o">(</span><span class="n">customConf</span><span class="o">))</span>
</pre>
<p>上面把設定檔內容直接儲存成字串，然後用 ConfigFactory.load 就可以產生設定檔了，不過一直放在程式碼裡面也不是一件健康的事情。
所以還是花了一點時間處理之前在 Eclipse 上面遇到的問題。</p>
<p>不過俗話說得好，越難找的 Bug 越蠢 ... 我又再次驗證了這個道理 Orz</p>
<p>如果你是使用 sbt 上面的 sbt-eclipse 來建立 Eclipse Project，由於 plugin 不貼心或者很貼心的設計。
他在 Eclipse 裡面並不會幫你建立 resources 的 source folder，
所以請手動在 src/main 下面建立一個 resources 的 source folder。</p>
<p>接著是笨點 Orz，請進入 Project 的設定畫面，然後選擇 Java Build Path 的內 Source 的 Tab。
請將 <strong>src/main/resources</strong> 的 <strong>Output folder</strong> 的路徑設定的跟 src/main/scala 一樣。</p>
<img alt="https://dl.dropbox.com/u/15537823/Blog/Akka%202.0%20%E7%AD%86%E8%A8%98%286%29%20-%20Dispatcher%20%E7%9A%84%E8%A8%AD%E5%AE%9A/Eclipse_Setting.png" src="https://dl.dropbox.com/u/15537823/Blog/Akka%202.0%20%E7%AD%86%E8%A8%98%286%29%20-%20Dispatcher%20%E7%9A%84%E8%A8%AD%E5%AE%9A/Eclipse_Setting.png"><p>之前都沒有部屬到我想要得地方就是因為他是放到 default output folder 也就是 bin 底下 Orz。</p>
<p>之後就可以參考 <a class="reference external" href="http://doc.akka.io/docs/akka/2.0.1/general/configuration.html">Configure</a> 與 <a class="reference external" href="http://doc.akka.io/docs/akka/2.0.2/scala/dispatchers.html">Dispatcher</a> 的內容去設定了。</p>
<p>這樣就解決了我之前一直懶得找得問題，再來應該就會詳細設定一下 Scatter-Gather 所要用的 Dispatcher 了。</p></div>
        
    <p>
        <a href="../posts/akka-2_0-note-6.html#disqus_thread" data-disqus-identifier="cache\posts\2012-06-17-akka-note-6-my-aggregator.html">Comments</a>

        </p></div>
        <div class="postbox">
        <h1><a href="../posts/akka-2_0-note-5.html">Akka 2.0 筆記(5) - Scatter Gather</a>
        <small>  
             Posted: 2012-06-15 08:58
        </small></h1>
        <hr><div><p>繼上次完全看不懂的 Dataflow 之後，我還是想要一個 Akka 的 Scatter Gather 實作方式，因此想試著自己實做看看。</p>
<p>下圖是 <a class="reference external" href="http://www.eaipatterns.com/">Enterprise Integration Patterns</a>  書中的 Scatter-Gather 概念圖。</p>
<img alt="http://www.eaipatterns.com/img/BroadcastAggregate.gif" src="http://www.eaipatterns.com/img/BroadcastAggregate.gif"><p>從圖中可以發現，中間對於 Vendor A、B 與 C 進行 Broadcast 的行為跟 Akka 內的 <a class="reference external" href="http://doc.akka.io/docs/akka/2.0/scala/routing.html">Router</a> 很像，
所以當我正在思考 Router 是否合適作為這種用途的時候，我想到了 <a class="reference external" href="http://letitcrash.com/">Let it Crash</a> 裡面 <a class="reference external" href="http://letitcrash.com/post/23532935686/watch-the-routees">Watch the Routees</a> 這篇文章。</p>
<p>這篇文章裡面他紀錄了在 Akka mailinglist 中回答別人問題時所寫的範例程式。</p>
<p>整個 use case 是要執行一個 Job，這個 Job 由許多 Tasks 組成，在執行的過程中</p>
<ol class="arabic simple"><li>會將這些 Tasks 透過 router 分派給 worker actors 執行。</li>
<li>最後收集所有 worker 的執行結果，並且將他們合併之後回傳。</li>
<li>除此之外， worker 在執行過程中發生錯誤時，應該要進行 retry，在進行幾次 retry 後依然有錯誤時，Worker 就會停止，並且中止整個 Job。</li>
</ol><div class="section" id="master-actor">
<h2>Master Actor</h2>
<pre class="code scala literal-block">
<span class="cm">/*
 *  Master Actor，負責整個工作運作流程的 Actor。
 *  接收 Job、分派 Task 以及當發現 Worker Terminal 或者是全部 Task 都執行完畢之後。
 *  將結果整理好之後回傳
 */</span>

<span class="k">class</span> <span class="nc">Master</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">results</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]()</span>
  <span class="k">var</span> <span class="n">replyTo</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="k">_</span>

<span class="cm">/*
 *  Router 這邊的 Router 種類是使用 RoundRobinRouter，
 *  他會輪流將 Message 傳給底下的 Worker。
 *  例如：若他底下有 5 個 Worker，那麼就會
 *
 *     Worker 1
 *     Worker 2
 *     ...
 *     Worker 5
 *     Worker 1
 *
 *  這樣的順序傳遞。
 */</span>

  <span class="k">val</span> <span class="n">router</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">Worker</span><span class="o">).</span>
    <span class="n">withRouter</span><span class="o">(</span><span class="nc">RoundRobinRouter</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span>
      <span class="n">supervisorStrategy</span> <span class="k">=</span> <span class="nc">OneForOneStrategy</span><span class="o">(</span>
        <span class="n">maxNrOfRetries</span> <span class="k">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">case</span> <span class="k">_:</span> <span class="kt">IOException</span> <span class="o">=&gt;</span> <span class="nc">Restart</span>
        <span class="o">})),</span> <span class="n">name</span> <span class="k">=</span> <span class="s">"router"</span><span class="o">)</span>

  <span class="n">router</span> <span class="o">!</span> <span class="nc">CurrentRoutees</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">RouterRoutees</span><span class="o">(</span><span class="n">routees</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">routees</span> <span class="n">foreach</span> <span class="n">context</span><span class="o">.</span><span class="n">watch</span>

    <span class="k">case</span> <span class="s">"start"</span> <span class="k">=&gt;</span>
      <span class="n">replyTo</span> <span class="k">=</span> <span class="n">sender</span>
      <span class="k">for</span> <span class="o">(</span><span class="n">id</span> <span class="k">←</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span> <span class="n">router</span> <span class="o">!</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="s">"22"</span><span class="o">)</span>

    <span class="k">case</span> <span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">result</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">results</span> <span class="o">+=</span> <span class="o">(</span><span class="n">id</span> <span class="o">-&gt;</span> <span class="n">result</span><span class="o">)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">results</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">10</span><span class="o">)</span>
        <span class="n">replyTo</span> <span class="o">!</span> <span class="n">results</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">sum</span>

    <span class="k">case</span> <span class="nc">Terminated</span><span class="o">(</span><span class="n">actor</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">replyTo</span> <span class="o">!</span> <span class="o">-</span><span class="mi">1</span>
      <span class="n">context</span><span class="o">.</span><span class="n">stop</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre>
<div class="section" id="id1">
<h3>Master Actor 的初始化</h3>
<p>上面的程式碼的註解有稍微介紹一下 Master 與 Router 的功能，這邊就針對程式碼的運作內容作些講解。</p>
<p>首先我們先看到這段程式碼</p>
<pre class="code scala literal-block">
<span class="n">router</span> <span class="o">!</span> <span class="nc">CurrentRoutees</span>
</pre>
<p><strong>CurrentRoutess</strong> 這邊困擾了我一段時間，因為我在 Akka 的文件裡面並沒有看到這個物件的說明，且在 API Document 裡面我也沒有看到相關的介紹 Orz ...</p>
<p>一直到仔細看 receive 裡面的內容之後才發現，這程式碼的功能是發一個 Message 給 Router，Router 在接收到這個訊息之後，
就會將目前 Router 裡面的所有的 Worker Actor（在 Let it Crash 裡面稱他為 Routee） 用 RouterRoutees 這個 case class 包裝回傳。</p>
<!-- code-block

case RouterRoutees(routees) =>
     routees foreach context.watch -->
<p>之後就可以利用 context.watch 將這個 Worker Actor 註冊起來。</p>
<p>這樣當 Worker Actor 因為錯誤太多次而結束的時候，就會接收到一個 Terminated 的 Message，
之後我們就回傳 -1 並且呼叫 context.stop(self) 結束 Master Actor，這也會連帶讓 Worker Actor 結束。</p>
<!-- code-block

case Terminated(actor) =>
   replyTo ! -1
   context.stop(self) -->
</div>
<div class="section" id="master-actor-scatter-gather">
<h3>Master Actor 的 Scatter 與 Gather</h3>
<p>說到 Scatter 的部份的話我想應該就要介紹一下我們這邊使用的 Router 了。</p>
<p>Router 其實本身跟我們這邊所實做的 Master Actor 很像，透過 Router 就可以將訊息分派給他底下的 Actor ，他就有點像是仲介商一樣。
你把要做的工作交給他，他會負責找到合適的人將工作分派出去。</p>
<p>Router 分派工作的方式有好幾種，可以到  <a class="reference external" href="http://doc.akka.io/docs/akka/2.0/scala/routing.html">Router</a>  的文件看一下，這邊使用的是經典的 RoundRobinRouter。</p>
<p>他會將工作輪流 <strong>forward</strong> 給底下的 Actor，這邊會用到 forward 是因為在 Akka 裡面，當你傳送一個 Message 給某個 Actor 的時候，
其實還會附帶上了 Sender 的資訊，所以如果 Message 的傳送路徑是用一般的傳送方式的話</p>
<blockquote>
Main -&gt; Router -&gt; Worker Actor</blockquote>
<p>那麼 Worker Actor 的 Sender 就會變成 Router，所以 Router 所使用的傳遞方式是 forward，這樣 Worker Actor 接收到 Message 之後就還是會認為 Main 是 Sender。
這樣才能將訊息正確的回傳回去。</p>
<p>Scatter 的部份就這麼簡單解決，但是下一個 Gather 的部份就比較麻煩了。
理由很簡單。因為 Router 只有負責分派的部份，Worker Actor 回傳的對象是一開始發 Message 的 Actor，
所以要另外針對回傳的 Message 作處理。下面的程式碼會在回傳的訊息累積到 10 個之後才將全部一起加總回傳。</p>
<pre class="code scala literal-block">
<span class="k">case</span> <span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">result</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
   <span class="n">results</span> <span class="o">+=</span> <span class="o">(</span><span class="n">id</span> <span class="o">-&gt;</span> <span class="n">result</span><span class="o">)</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">results</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">10</span><span class="o">)</span>
     <span class="n">replyTo</span> <span class="o">!</span> <span class="n">results</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">sum</span>
</pre>
<p>但是很明顯的，這樣還不足夠，如果同時間 Master Actor 接收到多個 Job，那麼要如何分辨 Worker Actor 所回傳的 Result 是哪個 Job 的？</p>
<p>目前想到的解決方式有</p>
<ol class="arabic simple"><li>簡單來說就是限制讓一個 Master Actor 同時只會有一個 Job 進行，如果有多個 Job 要進行就使用多個 Master Actor，附帶一題Actor 的數量並不代表 Thread 的數量，這部份可以透過 Dispatcher 的設定來控制。</li>
<li>增加 Job ID，讓每個 Job 都有自己的 ID，並且這個 ID 也會加在 Result 裡面，這樣就可以辨識 Result 是哪個 Job的了。</li>
</ol><p>本來我覺得第一個方法是不可行的，因為這樣太浪費資源且每次都要建立 Master Actor 很麻煩。
但是這樣的作法很單純也很好擴充，反正只要增加 Master Actor 就能多處理幾個 Job，要管理資源就等於管理 Master Actor 的數量就好了。</p>
<p>第二種作法會增加整個程式的複雜度，因為需要多一個 Map 來暫存 Result（光這個就有點麻煩了），需要多傳遞 Job ID 的資訊等。但好處應該就是會比較節省記憶體與 CPU 等。</p>
<p>但是在這個 CPU、Memory 不值錢的年代且這個又只是我的玩具的，所以我會選擇第一種方式來實做。</p>
</div>
</div>
<div class="section" id="worker-actor">
<h2>Worker Actor</h2>
<p>這是在 Let it Crash 裡面 Worker Actor 的程式碼，他接收的 Message 型態很簡單只有一種 (id,s:String)，這是在 Scala 稱之為 Tuple 的物件。
會有兩種是因為這個範例會模擬當 Worker Actor 執行發生 Exception 的情況。</p>
<pre class="code scala literal-block">
<span class="k">class</span> <span class="nc">Worker</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">if</span> <span class="nc">Random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">=&gt;</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">IOException</span><span class="o">(</span><span class="s">"failed"</span><span class="o">)</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">sender</span> <span class="o">!</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="n">toInt</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">preRestart</span><span class="o">(</span>
    <span class="n">reason</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Any</span><span class="o">])</span> <span class="o">{</span>
    <span class="c1">// retry
</span>    <span class="n">message</span> <span class="n">foreach</span> <span class="o">{</span> <span class="n">self</span> <span class="n">forward</span> <span class="k">_</span> <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre>
<p>比較有趣的是 preRestart ，這可以跟前面 Master Actor 內的 Router 一起看一下。</p>
<pre class="code scala literal-block">
<span class="k">val</span> <span class="n">router</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">Worker</span><span class="o">).</span>
    <span class="n">withRouter</span><span class="o">(</span>
    <span class="nc">RoundRobinRouter</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span>
      <span class="n">supervisorStrategy</span> <span class="k">=</span> <span class="nc">OneForOneStrategy</span><span class="o">(</span>
        <span class="n">maxNrOfRetries</span> <span class="k">=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">case</span> <span class="k">_:</span> <span class="kt">IOException</span> <span class="o">=&gt;</span> <span class="nc">Restart</span>
        <span class="o">})),</span> <span class="n">name</span> <span class="k">=</span> <span class="s">"router"</span><span class="o">)</span>
</pre>
<p>上面的 OneForOneStrategy 是 Akka 的特產，他可以設定 Supervisor（就是該 Actor 的管理者，例如 Worker Actor 的 supervisor 是 Router）</p>
<p>對於他底下 Actor 的應對策略。這邊是設定當 Worker Actor 有丟出 IOException 的時候，所採取的應對是將該 Worker Actor Restart。
但是這個 restart 次數有限制，在 maxNrOfRetries = 2 ，因此 Worker Actor 最多只會 Restart 兩次，兩次之後就會被停止並且傳一個 Terminated 的訊息給 Master Actor。</p>
<p>而 preRestart 裡面做的事情就是就是在 Restart 前將目前的 Message 全部用 forward 的方式傳給自己一次，否則 Restart 後這些 message 就會被清理掉。
這樣之前的工作就會遺失了。</p>
<p>Let it Crash 的 <a class="reference external" href="http://letitcrash.com/post/23532935686/watch-the-routees">Watch the Routees</a> 幫助真的很大，加上最近再看 <a class="reference external" href="http://www.amazon.com/Scala-Depth-Joshua-Suereth-D/dp/1935182706">Scala in Depth</a>  對於要做的 Scatter-Gather 比較有一些想法了，
下一篇應該就會說明如何時做的。</p>
</div>
<div class="section" id="id2">
<h2>下集預告 ?</h2>
<img alt="https://dl.dropbox.com/u/15537823/Blog/Akka%202.0%20%E7%AD%86%E8%A8%98%285%29%20-%20Scatter%20Gather/Photo%2012-6-16%20%E4%B8%8B%E5%8D%8810%2042%2021.png" src="https://dl.dropbox.com/u/15537823/Blog/Akka%202.0%20%E7%AD%86%E8%A8%98%285%29%20-%20Scatter%20Gather/Photo%2012-6-16%20%E4%B8%8B%E5%8D%8810%2042%2021.png"></div></div>
        
    <p>
        <a href="../posts/akka-2_0-note-5.html#disqus_thread" data-disqus-identifier="cache\posts\2012-06-15-akka-note-5-aggregator.html">Comments</a>

        </p></div>
        <div class="postbox">
        <h1><a href="../posts/akka-2_0-note-4.html">Akka 2.0 筆記(4) - Dataflow 請不要期待這篇我會提到什麼</a>
        <small>  
             Posted: 2012-06-12 21:55
        </small></h1>
        <hr><div><p>這整篇的原因起於，洗澡的時候想到的，
Akka 的 Future 到底有沒有存在的意義呢？</p>
<p>因為當一個 Actor 用 reply 或者 sender 回傳結果的時候，其實可以再 receive 不同的型態的 Message 就好了。
而且這樣還不會因為 Await 而需要 block thread，減少 dead lock 的發生。
我之前就幹過很蠢的事情，因為 Actor 把 Thread Pool 裡面的 Thread 用光了，所以他底下幫他工作的 Actor 就取不到 Thread 可以執行，
因此全部 Timeout Orz ...</p>
<p>目前唯一能想到的用法就是在發出訊息的地方不是一個 Actor 的時候，這時候就沒有 receive 可以接收結果了。
所以需要使用 Future 來等待結果，也就是 Future 應該只被用在需要等待的時候，如果是在一個 Actor 被執行的時候使用 Future。
很容易浪費掉一個 Thread，應該是要另外開一個新的 case class 來專門處理結果才是。</p>
<p>但是這邊又出現了一個更複雜的問題了，因為我將工作分給不同的 Actor 去執行，必須要等到所有 Actor 都執行完畢，整合所有的結果。
那麼如果是用 receive 我要怎樣才能知道我所有的工作都已經完成了呢？</p>
<p>簡單來說，我就是需要實做一個  <a class="reference external" href="http://www.eaipatterns.com/BroadcastAggregate.html">Scatter-Gather</a> ，才會莫名其妙的看到 Akka 的 Dataflow。</p>
<div class="section" id="akka-dataflow">
<h2>Akka Dataflow</h2>
<p>起因在於我用 Scatter-Gather 與 Akka 搜尋文章的時候找到這篇 <a class="reference external" href="http://blog.vasilrem.com/scatter-gather-with-akka-dataflow">Scatter-Gather with Akka Dataflow</a> 。
一看裡面的 Code 真是驚為天人，我一行都看不懂 Orz ...</p>
<p>然後 Akka  <a class="reference external" href="http://doc.akka.io/docs/akka/2.0/scala/dataflow.html">Dataflow Concurrency</a> 的內容又非常的精簡 Orz，而且他又用到了 <a class="reference external" href="http://www.scala-lang.org/node/2096">Scala Continuations</a> ，
這東西的文件也非常的 Orz，連 Programming in Scala 2nd 都沒有提到這個東西，讓我完全放棄這個東西 Orz ..</p>
<p>但是找到都找到了，我想實做個標本出來也不錯，所以才會有這篇東西。</p>
<p>下面這個版本改自上面所提到的 <a class="reference external" href="http://blog.vasilrem.com/scatter-gather-with-akka-dataflow">Scatter-Gather with Akka Dataflow</a></p>
<p>因為那個 Blog 的範例我估計來自於 Akka 1.3.1 之前的版本，所以我做了一些更動才能在 Akka 2.0 上面跑。</p>
<p>很幸運或者是很不幸的是 Dataflow 的部份則是從 Akka 1.x 就沒有變動過了，所以基本邏輯都沒有改變。</p>
<pre class="code scala literal-block">
<span class="k">import</span> <span class="nn">scala.util.continuations._</span>

<span class="k">import</span> <span class="nn">akka.actor.Actor</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorRef</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span>
<span class="k">import</span> <span class="nn">akka.actor.Props</span>
<span class="k">import</span> <span class="nn">akka.dispatch.Future.flow</span>
<span class="k">import</span> <span class="nn">akka.dispatch._</span>
<span class="k">import</span> <span class="nn">akka.pattern.ask</span>
<span class="k">import</span> <span class="nn">akka.util.duration._</span>
<span class="k">import</span> <span class="nn">akka.util.Timeout</span>

<span class="k">object</span> <span class="nc">ScatterGatherDataFlow</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">timeout</span> <span class="k">=</span> <span class="nc">Timeout</span><span class="o">(</span><span class="mi">10</span> <span class="n">seconds</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">()</span>
    <span class="k">val</span> <span class="n">recipients</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">Recipient</span><span class="o">(</span><span class="n">i</span><span class="o">))))</span>
    <span class="k">val</span> <span class="n">aggregator</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">Aggregator</span><span class="o">(</span><span class="n">recipients</span><span class="o">)))</span>
    <span class="k">val</span> <span class="n">results1</span> <span class="k">=</span> <span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">aggregator</span> <span class="o">?</span> <span class="nc">Message</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">),</span> <span class="n">timeout</span><span class="o">.</span><span class="n">duration</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">results2</span> <span class="k">=</span> <span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">aggregator</span> <span class="o">?</span> <span class="nc">Message</span><span class="o">(</span><span class="s">"World"</span><span class="o">),</span> <span class="n">timeout</span><span class="o">.</span><span class="n">duration</span><span class="o">)</span>

    <span class="n">results1</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Future</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="n">map</span> <span class="o">{</span> <span class="n">res</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"Result: %s"</span> <span class="n">format</span> <span class="o">(</span><span class="n">res</span><span class="o">))</span>
    <span class="o">}</span>
    <span class="n">results2</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Future</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="n">map</span> <span class="o">{</span> <span class="n">res</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"Result: %s"</span> <span class="n">format</span> <span class="o">(</span><span class="n">res</span><span class="o">))</span>
    <span class="o">}</span>

    <span class="n">system</span><span class="o">.</span><span class="n">awaitTermination</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Aggregator</span><span class="o">(</span><span class="n">recipients</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">ActorRef</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>

  <span class="k">implicit</span> <span class="k">val</span> <span class="n">defaultDispatcher</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">dispatcher</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">timeout</span> <span class="k">=</span> <span class="nc">Timeout</span><span class="o">(</span><span class="mi">10</span> <span class="n">seconds</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">msg</span> <span class="k">@</span> <span class="nc">Message</span><span class="o">(</span><span class="n">text</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"Started processing message `%s`"</span> <span class="n">format</span> <span class="o">(</span><span class="n">text</span><span class="o">))</span>

      <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="nc">Promise</span><span class="o">[</span><span class="kt">String</span><span class="o">]()</span>
      <span class="k">val</span> <span class="n">promises</span> <span class="k">=</span> <span class="nc">List</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="n">recipients</span><span class="o">.</span><span class="n">size</span><span class="o">)(</span><span class="nc">Promise</span><span class="o">[</span><span class="kt">String</span><span class="o">]())</span>

      <span class="n">recipients</span><span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">promises</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span>
        <span class="k">case</span> <span class="o">(</span><span class="n">recipient</span><span class="o">,</span> <span class="n">promise</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="o">(</span><span class="n">recipient</span> <span class="o">?</span> <span class="n">msg</span><span class="o">).</span><span class="n">mapTo</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="n">map</span> <span class="o">{</span> <span class="n">result</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span>
            <span class="n">println</span><span class="o">(</span><span class="s">"Binding recipient's response: %s"</span> <span class="n">format</span> <span class="o">(</span><span class="n">result</span><span class="o">))</span>
            <span class="n">flow</span> <span class="o">{</span>
              <span class="n">promise</span> <span class="o">&lt;&lt;</span> <span class="n">result</span>
            <span class="o">}</span>
          <span class="o">}</span>
      <span class="o">}</span>

      <span class="n">flow</span> <span class="o">{</span>
          <span class="k">def</span> <span class="n">gather</span><span class="o">(</span><span class="n">promises</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Future</span><span class="o">[</span><span class="kt">String</span><span class="o">]],</span> <span class="n">result</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">@cps</span><span class="o">[</span><span class="kt">Future</span><span class="o">[</span><span class="kt">Any</span><span class="o">]]</span> <span class="k">=</span>
            <span class="n">promises</span> <span class="k">match</span> <span class="o">{</span>
              <span class="k">case</span> <span class="n">head</span> <span class="o">::</span> <span class="n">tail</span> <span class="k">=&gt;</span> <span class="n">gather</span><span class="o">(</span><span class="n">tail</span><span class="o">,</span> <span class="n">head</span><span class="o">()</span> <span class="o">+</span> <span class="n">result</span><span class="o">)</span>
              <span class="k">case</span> <span class="nc">Nil</span>          <span class="k">=&gt;</span> <span class="n">result</span>
            <span class="o">}</span>

        <span class="n">println</span><span class="o">(</span><span class="s">"Binding result..."</span><span class="o">)</span>
        <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">gather</span><span class="o">(</span><span class="n">promises</span><span class="o">)</span>
      <span class="o">}</span>

      <span class="n">sender</span> <span class="o">!</span> <span class="n">result</span>
  <span class="o">}</span>

<span class="o">}</span>

<span class="k">class</span> <span class="nc">Recipient</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Message</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span>
      <span class="n">sender</span> <span class="o">!</span> <span class="o">(</span><span class="s">"%s, [%s]! "</span><span class="o">.</span><span class="n">format</span><span class="o">(</span><span class="n">msg</span><span class="o">,</span> <span class="n">id</span><span class="o">))</span>
  <span class="o">}</span>

<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Message</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</pre>
<p>附上執行結果</p>
<!-- code-block

Started processing message `Hello`
Started processing message `World`
Binding result...
Binding result...
Binding recipient's response: Hello, [1]!
Binding recipient's response: Hello, [2]!
Binding recipient's response: Hello, [3]!
Binding recipient's response: Hello, [4]!
Binding recipient's response: Hello, [5]!
Result: Hello, [5]! Hello, [4]! Hello, [3]! Hello, [2]! Hello, [1]!
Binding recipient's response: World, [2]!
Binding recipient's response: World, [1]!
Binding recipient's response: World, [3]!
Binding recipient's response: World, [4]!
Binding recipient's response: World, [5]!
Result: World, [5]! World, [4]! World, [3]! World, [2]! World, [1]! -->
<p>我目前只有做到將這段程式碼修改到可以動而已，實際整個運作流程與大概還不是完全了解。</p>
<p>一方面是因為有關於 Dataflow 的資料太少，二來是 Scala Continuations 的資料也很少 Orz 。
並且這個功能我覺得不太好 Debug ，閱讀上也有點不習慣，因此不會採用這個方式。
或許有一天我了解了 Dataflow 的好的時候我會在回頭把這程式碼的說明補齊。</p>
</div>
<div class="section" id="eclipse-sbt">
<h2>Eclipse 與 Sbt 的設定</h2>
<p>上面這段程式碼由於有用到 <a class="reference external" href="http://www.scala-lang.org/node/2096">Scala Continuations</a>  所以 Eclipse 或者 sbt 需要作一些設定，讓他可以使用 scala 的 continuations plugin。</p>
<p>Eclipse 的部份需要在 Compiler Standard 的設定中 p 的部份增加 <strong>continuations:enable</strong></p>
<img alt="https://dl.dropbox.com/u/15537823/Blog/2012-06-12-akka-dataflow/ScalaEclipse_continuations.png" src="https://dl.dropbox.com/u/15537823/Blog/2012-06-12-akka-dataflow/ScalaEclipse_continuations.png"><p>在 Compiler Advanced 的設定中 Xplugin 增加 <strong>libcontinuations.jar</strong></p>
<img alt="https://dl.dropbox.com/u/15537823/Blog/2012-06-12-akka-dataflow/ScalaEclipse_continuations_2.png" src="https://dl.dropbox.com/u/15537823/Blog/2012-06-12-akka-dataflow/ScalaEclipse_continuations_2.png"><p>如果是 sbt 的話只要增加下面的內容到 <strong>build.sbt</strong> 裡面即可。</p>
<!-- code-block

autoCompilerPlugins := true

libraryDependencies <+= scalaVersion { v => compilerPlugin("org.scala-lang.plugins" % "continuations" % "2.9.1") }

scalacOptions += "-P:continuations:enable" -->
</div></div>
        
    <p>
        <a href="../posts/akka-2_0-note-4.html#disqus_thread" data-disqus-identifier="cache\posts\2012-06-12-akka-dataflow.html">Comments</a>

        </p></div>
        <div class="postbox">
        <h1><a href="../posts/akka-2_0-note-3.html">Akka 2.0 筆記(3) - Future 之實在不是我想要拖稿</a>
        <small>  
             Posted: 2012-06-10 17:30
        </small></h1>
        <hr><div><p>而是我實在是不擅長寫作，過去作文只有 20 分真的不是拿假的。
前一篇的 <strong>開始使用 Future</strong> 只有介紹一些基本的使用方式而已，然後依照前面的程式碼是絕對跑不起來的 Orz ...</p>
<p>原因在於 Future 需要一個 Execution Contexts 類似 Java 裡面的 Executor，也就是 Thread Pool。</p>
<div class="section" id="execution-contexts">
<h2>Execution Contexts</h2>
<p>因為 Future 除了跟 Actor 配合使用之外，也可以直接使用。</p>
<p>例如前面與 Actor 配合使用的例子scala</p>
<pre class="code scala literal-block">
<span class="k">val</span> <span class="n">list</span> <span class="k">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"Tony"</span><span class="o">,</span><span class="s">"Lion"</span><span class="o">,</span><span class="s">"Teddy"</span><span class="o">,</span><span class="s">"Brain"</span><span class="o">,</span><span class="s">"Jess"</span><span class="o">,</span><span class="s">"Kay"</span><span class="o">,</span><span class="s">"Michael"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">listOfFutures</span> <span class="k">=</span> <span class="n">list</span> <span class="n">map</span> <span class="o">{</span>
   <span class="n">name</span> <span class="k">=&gt;</span>
      <span class="o">(</span><span class="n">countActor</span> <span class="o">?</span> <span class="n">name</span><span class="o">).</span><span class="n">mapTo</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="o">}</span>
<span class="k">val</span> <span class="n">futureList</span> <span class="k">=</span> <span class="nc">Future</span><span class="o">.</span><span class="n">sequence</span><span class="o">(</span><span class="n">listOfFutures</span><span class="o">)</span>
</pre>
<p>其實可以改成這樣:</p>
<pre class="code scala literal-block">
<span class="k">val</span> <span class="n">futureList</span> <span class="k">=</span> <span class="nc">Future</span><span class="o">.</span><span class="n">sequence</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">name</span> <span class="k">=&gt;</span> <span class="nc">Future</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="n">length</span><span class="o">)))</span>
</pre>
<p>因此在使用 Future 之前必須要設定 ExecutionContext 讓 Future 可用來執行工作。</p>
<dl class="docutils"><dt>P.S</dt>
<dd>這樣的結果也是會回傳一個 Future[List[Int]]。
很明顯的這樣的作法簡單很多，因為少建立 Actor 也不需要再將 Actor 所回傳的值轉型（就是前面看到的 mapTo[Int]）。
我是還蠻喜歡這樣做的，不過由於後面要使用到 Router 所以就沒有直接使用 Future 了。</dd>
</dl><div class="section" id="execution-context">
<h3>設定 Execution Context</h3>
<p>雖然文件中有提到如果 scope 內存在 ActorSystem ，他會自己使用 ActorSystem 的 default dispatcher，
不過很可惜的這個功能我沒有測試出來，不然就是我誤解了這段話的意思。
如果有朝一日我突然開悟想通了再來補上這一段。</p>
<p>而在 Akka 裡面所有的 Dispatcher 都是繼承自 ExecutionContext
所以要設定這個也不太花時間。</p>
<p>如果要使用 Future 的是一個 Actor，那麼只要直接設定 Actor 的 dispatcher 就可以了。</p>
<pre class="code scala literal-block">
<span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span><span class="o">{</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">defaultDispatch</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">dispatcher</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="o">}</span>
</pre>
<p>至於為什麼要使用 implicit 呢？因為 Future 的 Function 中 dispatcher 都是用 implicit 的型態，
所以如果沒有傳參數給他的時候，他會自動在這個 scope 裡面找尋是否有宣告成 implicit 的 ExecutionContext 變數。</p>
<p>如果使用 Future 的地方不是在 Actor 內，或不想使用 Actor 的 dispatch。那麼可以自己建立 Java 的 Executor ，並且將他轉成 ExecutionContext。</p>
<pre class="code scala literal-block">
<span class="k">val</span> <span class="n">es</span> <span class="k">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="n">newFixedThreadPool</span><span class="o">(</span><span class="n">threadSize</span><span class="o">)</span>             <span class="c1">//Java Executor
</span><span class="k">implicit</span> <span class="k">val</span> <span class="n">ec</span> <span class="k">=</span> <span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">fromExecutorService</span><span class="o">(</span><span class="n">es</span><span class="o">)</span>
</pre>
<p>這樣在使用 Future 的時候他就會自動去找 ExecutionContext 來執行。</p>
</div>
</div>
<div class="section" id="future-exception">
<h2>如果 Future 執行的過程中有發生 Exception</h2>
<p>Future 用 <strong>recover</strong> 與 <strong>recoverWith</strong> 來處理 Future 執行過程中的所丟出的 Exception。</p>
<p>使用方式非常的簡單，寫起來也蠻漂亮的，只要在建立 Future 時使用 recover 或 recoverWith 並且加入要處理的例外就好了。</p>
<p>例如</p>
<pre class="code scala literal-block">
<span class="nc">Future</span><span class="o">(</span><span class="n">parsePage</span><span class="o">(</span><span class="n">pageNumber</span><span class="o">))</span> <span class="n">recover</span> <span class="o">{</span> <span class="k">case</span> <span class="n">e</span><span class="k">:</span><span class="kt">Exception</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Post</span><span class="o">]()</span> <span class="o">}</span>
</pre>
<p>上面表示當我執行 parsePage 時如果發生任何 Excetpion 那麼就回傳一個空的 list。</p>
<p>而 recover 與 recoverWith 的差別就在於，recoverWith 內的 Function 要回傳的型態是 Future[Int] 而 recover 則是 Int。</p>
<p>晚點整理一個使用 Future 的完整例子好了，現在寫的東西真的太不入流了 XDDDDDD
我很難把程式碼直接貼上來當範例。</p>
</div></div>
        
    <p>
        <a href="../posts/akka-2_0-note-3.html#disqus_thread" data-disqus-identifier="cache\posts\2012-06-10-akka-note-3-future.html">Comments</a>

        </p></div>
        <div class="postbox">
        <h1><a href="../posts/akka-2_0-note-2.html">Akka 2.0 筆記 (2) - 開始使用 Future</a>
        <small>  
             Posted: 2012-06-08 12:18
        </small></h1>
        <hr><div><p>以前再使用 Java Thread 的時候最困擾我的就是 Thread 之間的溝通。
要怎樣讓一個 Thread 去等待另外一個 Thread？要怎樣才能讓工作分配的平均？
最後是靠 BlockingQueue 才讓實作變得簡單一點，
不過想當然問題當然一大堆 ... Orz</p>
<p>所以想來實驗看看 Akka 的 Future 與 Router 到底是如何使用，與可以做到什麼事情。</p>
<div class="section" id="future">
<h2>Future</h2>
<p>請搭配 Akka 官網 <a class="reference external" href="http://doc.akka.io/docs/akka/2.0/scala/futures.html">Future</a> 服用。</p>
<p>看 Future 一定要看一下文件第一句話</p>
<blockquote>
In Akka, a Future is a data structure used to retrieve the result of some concurrent operation.</blockquote>
<p>是的，他只是一個 Data Structure 而已，<strong>Future 最主要的功能就是可以透過他取得 Actor 回傳的 message</strong>
也可以將他想成他代表我們未來會取得的回傳值，我想這也就是它叫做 Future 的原因了。</p>
<pre class="code scala literal-block">
<span class="k">implicit</span> <span class="k">val</span> <span class="n">timeout</span> <span class="k">=</span> <span class="nc">Timeout</span><span class="o">(</span><span class="mi">5</span> <span class="n">seconds</span><span class="o">)</span>
<span class="k">val</span> <span class="n">future</span> <span class="k">=</span> <span class="n">actor</span> <span class="o">?</span> <span class="n">msg</span> <span class="c1">// enabled by the "ask" import
</span><span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">future</span><span class="o">,</span> <span class="n">timeout</span><span class="o">.</span><span class="n">duration</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</pre>
<p>偷一下官網的範例，我們一行一行看上面的程式碼。</p>
<p>一開始的</p>
<pre class="code scala literal-block">
<span class="k">implicit</span> <span class="k">val</span> <span class="n">timeout</span> <span class="k">=</span> <span class="nc">Timeout</span><span class="o">(</span><span class="mi">5</span> <span class="n">seconds</span><span class="o">)</span>
</pre>
<p>就先忽略 implicit 吧，因為這邊還沒有用到 implicit 的特性。</p>
<p>現在只要知道他建立了一個 Timeout 物件，內容是 5 seconds，這個在之後設定 wait timeout 的時候會用到‧
為了避免無止盡的等待，在 Actor 裡面只要有關等待的操作都要給一個 Timeout 時間。</p>
<pre class="code scala literal-block">
<span class="k">val</span> <span class="n">future</span> <span class="k">=</span> <span class="n">actor</span> <span class="o">?</span> <span class="n">msg</span> <span class="c1">// enabled by the "ask" import</span>
</pre>
<p>這裡發一個 msg 給 actor ，特別需要注意的地方是這裡不是使用* ! <em>而是</em> ? <em>。
要使用這個 ? 需要 *import akka.pattern.ask</em>，跟 ! 不一樣的地方在於他會回傳一個 Future[Any] 物件</p>
<pre class="code scala literal-block">
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">future</span><span class="o">,</span><span class="n">timeout</span><span class="o">.</span><span class="n">duration</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</pre>
<p>最後使用 Await 來透過 Future 取得 Actor 的回傳值，並且設定一個 timeout 時間，如果時間到 Actor 沒有回傳任何東西的話，就會丟出一個 Timeout Exception。</p>
<div class="section" id="actor">
<h3>如果要等待很多個 Actor 回傳值呢？</h3>
<p>如果要將工作分派給多個 Actor 進行運作，那麼最直覺的想法就是</p>
<pre class="code scala literal-block">
<span class="k">val</span> <span class="n">f1</span> <span class="k">=</span> <span class="n">actor1</span> <span class="o">?</span> <span class="n">msg1</span>
<span class="k">val</span> <span class="n">f2</span> <span class="k">=</span> <span class="n">actor2</span> <span class="o">?</span> <span class="n">msg2</span>

<span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">f1</span><span class="o">,</span> <span class="mi">1</span> <span class="n">second</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">f2</span><span class="o">,</span> <span class="mi">1</span> <span class="n">second</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

<span class="k">val</span> <span class="n">f3</span> <span class="k">=</span> <span class="n">actor3</span> <span class="o">?</span> <span class="o">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">)</span>

<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">f3</span><span class="o">,</span> <span class="mi">1</span> <span class="n">second</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</pre>
<p>我先將工作發給 actor1 等他回傳，然後再發給 actor2 等待回傳，最後在將回傳結果發給 actor3。</p>
<p>為了要取得 a、b 而使用了 Await 兩次，這樣的作法非常沒有效率，因此有了 sequence 與 traverse 這兩個 function。</p>
<p>舉例來說，如果我有一個</p>
<pre class="code scala literal-block">
<span class="nc">List</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"Tony"</span><span class="o">,</span><span class="s">"Lion"</span><span class="o">,</span><span class="s">"Teddy"</span><span class="o">,</span><span class="s">"Brain"</span><span class="o">,</span><span class="s">"Jess"</span><span class="o">,</span><span class="s">"Kay"</span><span class="o">,</span><span class="s">"Michael"</span><span class="o">)</span>
</pre>
<p>並且想要這個 List 內所有字串的長度總和。</p>
<pre class="code scala literal-block">
<span class="k">val</span> <span class="n">list</span> <span class="k">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"Tony"</span><span class="o">,</span><span class="s">"Lion"</span><span class="o">,</span><span class="s">"Teddy"</span><span class="o">,</span><span class="s">"Brain"</span><span class="o">,</span><span class="s">"Jess"</span><span class="o">,</span><span class="s">"Kay"</span><span class="o">,</span><span class="s">"Michael"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">listOfFutures</span> <span class="k">=</span> <span class="n">list</span> <span class="n">map</span> <span class="o">{</span>
   <span class="n">name</span> <span class="k">=&gt;</span>
      <span class="o">(</span><span class="n">countActor</span> <span class="o">?</span> <span class="n">name</span><span class="o">).</span><span class="n">mapTo</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="o">}</span>
</pre>
<p>在這邊我們得到了一個型態為 List[Future[Int]] 的 listOfFutures，再來就可以使用 sequence 將其轉成 Future[List[Int]]
最後就可以使用 Await 來取得所有字串長度了，並且統計字數了。</p>
<pre class="code scala literal-block">
<span class="k">val</span> <span class="n">futureList</span> <span class="k">=</span> <span class="nc">Future</span><span class="o">.</span><span class="n">sequence</span><span class="o">(</span><span class="n">listOfFutures</span><span class="o">)</span>
<span class="k">val</span> <span class="n">lengthList</span> <span class="k">=</span> <span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">futureList</span><span class="o">,</span><span class="mi">1</span> <span class="n">second</span><span class="o">)</span>
</pre>
<p>而 sequence 與 traverse 兩個不一樣的地方在於說</p>
<p>sequence 接受一個 List[Future[A]] 轉成 Future[List[A]]。</p>
<pre class="code scala literal-block">
<span class="k">val</span> <span class="n">futureList</span><span class="k">:</span><span class="kt">Future</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Future</span><span class="o">.</span><span class="n">sequence</span><span class="o">((</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">100</span><span class="o">).</span><span class="n">toList</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">x</span><span class="k">=&gt;</span><span class="nc">Future</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">)))</span>
</pre>
<p>而 traverse 則是接受一個 List[B] 與一個 function (B=&gt;Future[A]) 最後也是產生 Future[List[A]]</p>
<pre class="code scala literal-block">
<span class="k">val</span> <span class="n">futureList</span><span class="k">:</span><span class="kt">Future</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Future</span><span class="o">.</span><span class="n">traverse</span><span class="o">((</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">100</span><span class="o">).</span><span class="n">toList</span><span class="o">)(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nc">Future</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">))</span>
</pre>
<p>用 traverse 的好處在於少產生了中間過程的 List[Future[Int]] (至少我們的程式碼看不到，背後實際上有沒有我就不確定了，不過文件是這樣說的)，而直接產生了 Future[List[Int]]。</p>
<p>寫了這麼久，才寫這麼一點點 Orz ... 而且還完全沒有進入重點。</p>
</div>
</div></div>
        
    <p>
        <a href="../posts/akka-2_0-note-2.html#disqus_thread" data-disqus-identifier="cache\posts\2012-05-23-akka-note-2-eventstream.html">Comments</a>

        </p></div>
        <div class="postbox">
        <h1><a href="../posts/akka-2_0-note-1.html">Akka 2.0 筆記 (1)</a>
        <small>  
             Posted: 2012-05-17 18:03
        </small></h1>
        <hr><div><p>因為我的程式還沒有寫完，所以是筆記 (1)，寫的過程應該還會有 2 3 ... 出現 Orz。</p>
<blockquote>
Akka 2.0 - 要升級了
你的時間的庫存量足夠嗎 ?</blockquote>
<p>Akka 進入了 2.0 時代，恭喜你如果你是用 1.x 的話，請準備改寫吧 ...
先從幾個方面來看 2.0 的新增事項。</p>
<p>以下算是筆記，如有錯誤請多指教</p>
<div class="section" id="actor">
<h2>Actor</h2>
<p>從官網範例來看，Actor 的架構還是跟之前一樣沒有什麼改變</p>
<pre class="code scala literal-block">
<span class="k">import</span> <span class="nn">akka.actor.Actor</span>
<span class="k">import</span> <span class="nn">akka.actor.Props</span>
<span class="k">import</span> <span class="nn">akka.event.Logging</span>

<span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">log</span> <span class="k">=</span> <span class="nc">Logging</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">,</span> <span class="k">this</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">"test"</span> <span class="k">=&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">"received test"</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span>      <span class="k">=&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">"received unknown message"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre>
<p>但是上面的程式碼你會看到一個有點陌生的東西 <em>context.system</em>。
2.0 建立 Actor 的方式已經有了改變，現在的 Actor 可以有階層關係（就像老鼠會一樣 Orz）。
從 Actor 的 context 中可以取得很多該 Actor 的資訊與操作方式。而 ActorSystem 建立出來的 Actor 就會位於最上層。</p>
<pre class="code scala literal-block">
<span class="k">object</span> <span class="nc">Main</span> <span class="k">extends</span> <span class="nc">App</span>
<span class="o">{</span>
  <span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">"MySystem"</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">myActor</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">MyActor</span><span class="o">],</span> <span class="n">name</span> <span class="k">=</span> <span class="s">"myactor"</span><span class="o">)</span>
<span class="o">}</span>
</pre>
<p>延續上面的例子，如果MyActor內需要建立其他Actor</p>
<pre class="code scala literal-block">
<span class="n">context</span><span class="o">.</span><span class="n">actorof</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">children</span><span class="o">],</span> <span class="n">name</span> <span class="k">=</span> <span class="s">"children"</span><span class="o">)</span>
</pre>
<p>利用這種階層關係有什麼好處呢？</p>
<p>在之前 Akka1.3 的時代，我就經歷過非常痛苦的過程，那時候還沒有像 2.0 這樣的階層關係。
所以如果我在停止一個 Actor 之前沒有先把他底下的 Actor 都停止的話，程式是沒有辦法正常結束的（因為還有 Actor 活著）。</p>
<p>所以必須 override Actor 裡面的 function 讓他在停止之前，會先去結束他底下的 Actor。
為了作到這件事，我還要多弄一個 List 去紀錄他有建立哪些 Actor。
然後拼命的發 message 叫 Actor 去死去死去死去死 Orz。</p>
<p>但是這些煩惱在2.0就通通不見啦！！！！！
現在要停止只要用</p>
<pre class="code scala literal-block">
<span class="n">context</span><span class="o">.</span><span class="n">stop</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>
</pre>
<p>就會幹掉底下的部屬之後再做掉自己，真是讓人清爽又愉快（煙）</p>
</div>
<div class="section" id="eventstream">
<h2>EventStream</h2>
<p>最早知道 EventStream 或 EventBus 這種架構是在 GWT 的時後，那時候一用實在驚為天人。
真是太方便了，雖然整體架構跟 Observer Pattern 一樣，但是人家就是用得很漂亮。</p>
<p>EventStream 只存在於 ActorSystem 底下，要使用 EventStream 的第一步就是先註冊 Actor 與他要接收的物件類型。</p>
<pre class="code scala literal-block">
<span class="k">import</span> <span class="nn">akka.actor.</span><span class="o">{</span> <span class="nc">Actor</span><span class="o">,</span> <span class="nc">DeadLetter</span><span class="o">,</span> <span class="nc">Props</span> <span class="o">}</span>

<span class="k">val</span> <span class="n">listener</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">d</span><span class="k">:</span> <span class="kt">DeadLetter</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">d</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}))</span>
<span class="n">system</span><span class="o">.</span><span class="n">eventStream</span><span class="o">.</span><span class="n">subscribe</span><span class="o">(</span><span class="n">listener</span><span class="o">,</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">DeadLetter</span><span class="o">])</span>
</pre>
<p>上面的程式碼產生了一個 listener 的 Actor 並且註冊說如果有 DeadLeatter 類型的物件送到 EventStream 內，就會傳送給他。
雖然文件說主要是拿來作 Log 或者是監聽事件，但我拿來當其他的用途，例如發給所有的 Actor 讓他們自己認領工作之類的。</p>
</div>
<div class="section" id="event-handler">
<h2>Event Handler</h2>
<p>Event Handler 是拿來作 log 的工具，可以實作一個 EventListener 來監聽所有的事件。
跟 Log4j 等工具一樣，可以分成</p>
<ul class="simple"><li>Error</li>
<li>Warning</li>
<li>Info</li>
<li>Debug</li>
</ul><p>看起來似乎可以拿來作為例外處理或者作一個事件重發的工具。</p>
<div class="section" id="eventlistener">
<h3>實作EventListener</h3>
<pre class="code scala literal-block">
<span class="k">val</span> <span class="n">errorHandlerEventListener</span> <span class="k">=</span> <span class="nc">Actor</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="k">new</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="n">self</span><span class="o">.</span><span class="n">dispatcher</span> <span class="k">=</span> <span class="nc">EventHandler</span><span class="o">.</span><span class="nc">EventHandlerDispatcher</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">EventHandler</span><span class="o">.</span><span class="nc">Error</span><span class="o">(</span><span class="n">cause</span><span class="o">,</span> <span class="n">instance</span><span class="o">,</span> <span class="n">message</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span>
    <span class="k">case</span> <span class="nc">EventHandler</span><span class="o">.</span><span class="nc">Warning</span><span class="o">(</span><span class="n">instance</span><span class="o">,</span> <span class="n">message</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span>
    <span class="k">case</span> <span class="nc">EventHandler</span><span class="o">.</span><span class="nc">Info</span><span class="o">(</span><span class="n">instance</span><span class="o">,</span> <span class="n">message</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span>
    <span class="k">case</span> <span class="nc">EventHandler</span><span class="o">.</span><span class="nc">Debug</span><span class="o">(</span><span class="n">instance</span><span class="o">,</span> <span class="n">message</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span>
    <span class="k">case</span> <span class="n">genericEvent</span> <span class="k">=&gt;</span> <span class="o">...</span>
  <span class="o">}</span>
<span class="o">})</span>
</pre>
<p>加入EventListener</p>
<pre class="code scala literal-block">
<span class="nc">EventHandler</span><span class="o">.</span><span class="n">addListener</span><span class="o">(</span><span class="n">errorHandlerEventListener</span><span class="o">)</span>
</pre>
<p>移除EventListener</p>
<pre class="code scala literal-block">
<span class="nc">EventHandler</span><span class="o">.</span><span class="n">removeListener</span><span class="o">(</span><span class="n">errorHandlerEventListener</span><span class="o">)</span>
</pre>
<p>Log 訊息</p>
<pre class="code scala literal-block">
<span class="nc">EventHandler</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="n">exception</span><span class="o">,</span> <span class="k">this</span><span class="o">,</span> <span class="n">message</span><span class="o">)</span>
<span class="nc">EventHandler</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">message</span><span class="o">)</span>
<span class="nc">EventHandler</span><span class="o">.</span><span class="n">warning</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">message</span><span class="o">)</span>
<span class="nc">EventHandler</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">message</span><span class="o">)</span>
<span class="nc">EventHandler</span><span class="o">.</span><span class="n">debug</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">message</span><span class="o">)</span>
</pre>
</div>
</div>
<div class="section" id="scheduler">
<h2>Scheduler</h2>
<p>Akka 內有附一個簡單的 Scheduler，他可以讓你排程什麼時候要發訊息給 Actor</p>
<pre class="code scala literal-block">
<span class="k">import</span> <span class="nn">akka.actor.Scheduler</span>

<span class="c1">//Sends messageToBeSent to receiverActor after initialDelayBeforeSending and then after each delayBetweenMessages
</span><span class="nc">Scheduler</span><span class="o">.</span><span class="n">schedule</span><span class="o">(</span><span class="n">receiverActor</span><span class="o">,</span> <span class="n">messageToBeSent</span><span class="o">,</span> <span class="n">initialDelayBeforeSending</span><span class="o">,</span> <span class="n">delayBetweenMessages</span><span class="o">,</span> <span class="n">timeUnit</span><span class="o">)</span>

<span class="c1">//Sends messageToBeSent to receiverActor after delayUntilSend
</span><span class="nc">Scheduler</span><span class="o">.</span><span class="n">scheduleOnce</span><span class="o">(</span><span class="n">receiverActor</span><span class="o">,</span> <span class="n">messageToBeSent</span><span class="o">,</span> <span class="n">delayUntilSend</span><span class="o">,</span> <span class="n">timeUnit</span><span class="o">)</span>
</pre>
</div>
<div class="section" id="event-driven">
<h2>Event Driven</h2>
<p>一直到最近在實作小玩具才想到的，我想這不是新的東西，可是用Akka或許可以把這件事情變得非常方便。
以前在學Design Pattern的時候，其實整體架構算是很容易理解的東西。</p>
<p>But ! 就是這個But，在寫的時候卻會常常綁手綁腳，例如MVC的Pattern，我到底要不要在Control中紀錄Model與View的位置，如果不紀錄的話我又要怎麼找到他們，然後整個執行流程又是如何？
這是一件很麻煩的事情，雖然現在用起來是沒啥感覺，但是我也常為了Model之間的溝通流程感到困擾。</p>
<p>小的在下我，寫論文的時候實作的東西其基礎架構是建立在JavaSpace上面，這個東西不要說現在沒啥人聽過了，就連我在用的時候都很悲劇。
但是他設計概念我覺得很棒，他提供一個Pool可以讓你把Object丟進去，有興趣的Process就可以自己去那個Pool搶。
但是這個東西就悲劇在他後來沒有在維護了，而且他的Server架設非常麻煩，API非常難用。</p>
<p>一直到後來在GWT中看到Event Bus，我覺得這真是TMD的好東西。
反正每個Model就是把Event丟到Event Bus裡面就好了，然後誰愛撿就撿去玩，射後不理真是男人的浪漫（誤）。
因此最近才想到，如果利用Akka來作一個類似JavaSpace的東西如何，每個Module都是一個獨立的Actor，Module在接收到工作把工作完成就，就將結果丟回Space。</p>
<p>舉個例子就像之前舉例舉到爛掉的某大論壇Parser，需要將文章內容紀錄到資料庫裡面，並且還要去下載相關的圖片。
因此我就模仿Eva Magi系統（大誤），將Parser Module、Data Module與Download Module各自獨立成一個Actor。
系統啟動的時候，由系統去建立Space，並且將這三個Module依照其MetaData的設定要將哪些Event傳送給他們（其實就是Observer Pattern）。</p>
<p>Parser定時自動去論壇取得文章內容，並且將內容丟到Space裡面。這時Data Module就可以將文章資料寫到資料庫中，而Download Module也同時進行下載。
這樣的架構可以視情況讓他是Single Thread或Multiple Thread的程式。只要好好管理Event的流動方式就可以了。</p>
<p>至於這樣的架構好不好測試呢？我覺得這樣寫有一個好處，就是可以強迫Programmer寫出沒有副作用的程式，因為你必須要將所以處理結果都丟回Space裡面。
因此測試的時候，只要建立該Module，並且傳送Mock Event給他就可以了，其他Module並不需要被建立起來。這樣的架構也降低了各Module之間的coupling。</p>
<p>最後如果想要作所謂的雲～～～～～～～～端系統（老實說連我都不知道啥鬼才叫TMD的雲～～～～～～端系統），就可以利用Akka的Remote Actor的功能，
將不同的Module丟到不同的機器上面作，甚至是同一個Module可以有好幾個來分工。</p>
<p>Wao cow 越想感覺越夢幻，有空來實作看看到底會遇到什麼問題好了。</p>
</div></div>
        
    <p>
        <a href="../posts/akka-2_0-note-1.html#disqus_thread" data-disqus-identifier="cache\posts\2012-05-17-akka-note-1.html">Comments</a>

        </p></div>
        <div class="postbox">
        <h1><a href="../posts/epubconverter-implement-note.html">實作 EPUBConverter 的筆記</a>
        <small>  
             Posted: 2012-05-11 18:19
        </small></h1>
        <hr><div><p>其實在學 Scala 的這一段時間中，我最困擾的就是到底怎樣才是好的 Scala 寫作風格。
因為 Scala 最吸引我的部份就是在於他的語法可以不斷的精鍊再精鍊，最後變成*魔法文字* Orz。
所以要怎樣善用 Scala 的語言特性，卻又不失可讀性，我覺得真的很難。
因此在這次的小工具實作中，我試著摸索 Curry 的用法。</p>
<div class="section" id="curry">
<h2>Curry</h2>
<p>說到教學文件，就一定要推一下 <a class="reference external" href="http://caterpillar.onlyfun.net/Gossip/Scala/index.html">良葛格的學習筆記</a> 裡面他有提到 <a class="reference external" href="http://caterpillar.onlyfun.net/Gossip/Scala/Curry.html">Curry</a>  的語法與何謂 Curry 。
但是我更喜歡在 jserv's blog <a class="reference external" href="http://blog.linux.org.tw/~jserv/archives/002029.html">以 C 語言實做 Functional Language 的 Currying</a>  看到的說明。</p>
<p>Curry 可以看成數學的多項式，舉例來說現在有一個多項式</p>
<blockquote>
F(X,Y) = X + Y</blockquote>
<p>那麼 Curry 的感覺就是我現在已知 X 為 10 之類的，然後將其代入，所以上面的多項式又變成另外一個多項式</p>
<blockquote>
F(Y) = 10 + Y</blockquote>
<p>如果將這段用 Scala 來表示就是</p>
<pre class="code scala literal-block">
<span class="c1">// 這是 F(X,Y)
</span><span class="k">def</span> <span class="n">F</span><span class="o">(</span><span class="n">X</span><span class="k">:</span><span class="kt">Int</span><span class="o">)(</span><span class="n">Y</span><span class="k">:</span><span class="kt">Int</span><span class="o">)={</span>
   <span class="n">X</span> <span class="o">+</span> <span class="n">Y</span>
<span class="o">}</span>

<span class="c1">// 帶入 X = 10
</span>
<span class="k">val</span> <span class="n">F1</span> <span class="k">=</span> <span class="n">F</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
</pre>
</div>
<div class="section" id="id2">
<h2>Curry 的使用案例</h2>
<p>在 jserv 的文章有提到一個 Ruby 目錄樹尋訪的範例，剛好我在這次有實作類似的東西，但是功力不足沒有辦法寫的像 Ruby 那麼優雅。</p>
<pre class="code scala literal-block">
<span class="k">def</span> <span class="n">walkDir</span><span class="o">(</span><span class="n">fileList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">File</span><span class="o">]</span> <span class="o">{})(</span><span class="n">expr</span><span class="k">:</span> <span class="o">(</span><span class="kt">File</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">fileList</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">file</span> <span class="o">::</span> <span class="n">files</span> <span class="k">=&gt;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="n">isDirectory</span><span class="o">)</span>
          <span class="n">walkDir</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="n">listFiles</span><span class="o">.</span><span class="n">toList</span> <span class="o">:::</span> <span class="n">files</span><span class="o">)(</span><span class="n">expr</span><span class="o">)</span>
        <span class="k">else</span>
        <span class="o">{</span>
          <span class="n">expr</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
          <span class="n">walkDir</span><span class="o">(</span><span class="n">files</span><span class="o">)(</span><span class="n">expr</span><span class="o">)</span>
        <span class="o">}</span>
      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
    <span class="o">}</span>
  <span class="o">}</span>
</pre>
<p>我想這樣寫最大的問題應該是會在</p>
<pre class="code scala literal-block">
<span class="n">walkDir</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="n">listFiles</span><span class="o">.</span><span class="n">toList</span> <span class="o">:::</span> <span class="n">files</span><span class="o">)(</span><span class="n">expr</span><span class="o">)</span>
</pre>
<p>這邊每次都會產生一個新的 List ，這是優點也是缺點，效率我想可能會差了一點，但是我不在意，反正這個程式不是一秒幾十萬上下的東西。
那麼這個東西可以怎麼用呢？</p>
<p>例如要印出所有資料夾底下的檔案</p>
<pre class="code scala literal-block">
<span class="n">walkDir</span><span class="o">(</span><span class="n">folder</span><span class="o">){</span><span class="n">println</span><span class="o">}</span>
</pre>
<p>刪除底下所有名稱包含 test 的檔案</p>
<pre class="code scala literal-block">
<span class="n">walkDir</span><span class="o">(</span><span class="n">folder</span><span class="o">){</span>
   <span class="n">file</span><span class="k">=&gt;</span>
      <span class="k">if</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="s">"test"</span><span class="o">))</span>
         <span class="n">file</span><span class="o">.</span><span class="n">delete</span>
<span class="o">}</span>
</pre>
<p>我另外一個有使用 Curry 的地方</p>
<pre class="code scala literal-block">
<span class="k">def</span> <span class="nc">InputToOutput</span><span class="o">(</span><span class="n">buffer</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">])(</span><span class="n">fis</span><span class="k">:</span> <span class="kt">InputStream</span><span class="o">,</span> <span class="n">fos</span><span class="k">:</span> <span class="kt">OutputStream</span><span class="o">)</span> <span class="k">=</span>
<span class="o">{</span>
   <span class="k">def</span> <span class="n">bufferReader</span><span class="o">(</span><span class="n">fis</span><span class="k">:</span> <span class="kt">InputStream</span><span class="o">)(</span><span class="n">buffer</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">])</span> <span class="k">=</span> <span class="o">(</span><span class="n">fis</span><span class="o">.</span><span class="n">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">),</span> <span class="n">buffer</span><span class="o">)</span>

   <span class="k">def</span> <span class="n">writeToOutputStream</span><span class="o">(</span><span class="n">reader</span><span class="k">:</span> <span class="o">(</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">Tuple2</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]],</span> <span class="n">fos</span><span class="k">:</span> <span class="kt">OutputStream</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
     <span class="k">val</span> <span class="o">(</span><span class="n">length</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span> <span class="k">=</span> <span class="n">reader</span><span class="o">(</span><span class="n">buffer</span><span class="o">)</span>
     <span class="k">if</span> <span class="o">(</span><span class="n">length</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">length</span><span class="o">)</span>
       <span class="n">writeToOutputStream</span><span class="o">(</span><span class="n">reader</span><span class="o">,</span> <span class="n">fos</span><span class="o">)</span>
     <span class="o">}</span> <span class="k">else</span>
       <span class="kc">true</span>
   <span class="o">}</span>

   <span class="n">writeToOutputStream</span><span class="o">(</span><span class="n">bufferReader</span><span class="o">(</span><span class="n">fis</span><span class="o">)</span><span class="k">_</span><span class="o">,</span> <span class="n">fos</span><span class="o">)</span>

 <span class="o">(</span><span class="n">fis</span><span class="o">,</span> <span class="n">fos</span><span class="o">)</span>
<span class="o">}</span>
</pre>
<p>這個 function 主要負責將 InputStream 的資料寫到 OutputStream。</p>
<p>第一個 Curry 是 InputToOutput 他讓我可以用 InputToOutput(buffer)_ 建立一個已經宣告好 buffer 的 IO 操作 function。
這樣我就不用每次都還要找一個 buffer 才可以開始我的 IO 操作，反正 buffer 的內容讀完就可以丟了，不過這個沒有考慮 multiple thread 的情況就是。</p>
<p>第二個 Curry 是讓 Read InputStream 的 function 跟傳進來的 InputStream 綁定，這單純只是想簡化之後的操作，讓我可以不用再考慮 InputStream 這個參數。
反正我只要給一個 buffer 他就會自動讀進來，並且回傳讀取的大小與 buffer 本身。</p>
<p>解壓縮的部份也用了類似的技巧</p>
<pre class="code scala literal-block">
<span class="k">def</span> <span class="n">unzipAllFile</span><span class="o">(</span><span class="n">entryList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">ZipEntry</span><span class="o">],</span> <span class="n">getInputStream</span><span class="k">:</span> <span class="o">(</span><span class="kt">ZipEntry</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="nc">InputStream</span><span class="o">,</span> <span class="n">targetFolder</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">entryList</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">entry</span> <span class="o">::</span> <span class="n">entries</span> <span class="k">=&gt;</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="n">isDirectory</span><span class="o">)</span>
          <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">targetFolder</span><span class="o">,</span> <span class="n">entry</span><span class="o">.</span><span class="n">getName</span><span class="o">).</span><span class="n">mkdirs</span>
        <span class="k">else</span>
        <span class="o">{</span>
          <span class="k">val</span> <span class="o">(</span><span class="n">input</span><span class="o">,</span><span class="n">output</span><span class="o">)</span> <span class="k">=</span> <span class="nc">InputToOutput</span><span class="o">(</span><span class="n">getInputStream</span><span class="o">(</span><span class="n">entry</span><span class="o">),</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">targetFolder</span><span class="o">,</span> <span class="n">entry</span><span class="o">.</span><span class="n">getName</span><span class="o">)))</span>

          <span class="n">input</span><span class="o">.</span><span class="n">close</span>
          <span class="n">output</span><span class="o">.</span><span class="n">close</span>
        <span class="o">}</span>

        <span class="n">unzipAllFile</span><span class="o">(</span><span class="n">entries</span><span class="o">,</span> <span class="n">getInputStream</span><span class="o">,</span> <span class="n">targetFolder</span><span class="o">)</span>

      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
        <span class="kc">true</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre>
<p>大概就這些了，總覺得程式還是寫的不夠多，這些 Code 應該可以寫的再更優雅一點才是。</p>
</div></div>
        
    <p>
        <a href="../posts/epubconverter-implement-note.html#disqus_thread" data-disqus-identifier="cache\posts\2012-05-11-epubconverter-implement-note.html">Comments</a>

        </p></div>
        <div class="postbox">
        <h1><a href="../posts/epubconverter.html">epub格式簡轉繁小工具</a>
        <small>  
             Posted: 2012-05-11 16:56
        </small></h1>
        <hr><div><div class="section" id="id1">
<h2>下載點</h2>
<p><a class="reference external" href="https://github.com/Swind/EPUBConverter/downloads">EPUBConverter 0.0.1</a></p>
<p>這個版號我覺得也沒有機會到 0.0.2 了，不過還是讓我命名個版號滿足小小的虛榮心好了。</p>
</div>
<div class="section" id="id2">
<h2>不負責任的使用教學</h2>
<p>這只是一個非常簡單的小工具，用 Scala 撰寫而成，因此執行環境需要使用 JVM。
我只有測試過 JDK 7 的環境，理論上 JDK 6 應該也沒有問題。
如果有人有測試到有問題的話（默...）我也不知道有沒有時間改 Orz。</p>
<div class="section" id="id3">
<h3>轉換方式</h3>
<p>轉換方式感謝 <a class="reference external" href="http://jeremy.ssinrc.org/?p=327">六度數位空間</a> 的分享。
其實 epub 的格式是以 zip 格式壓縮，所以這個程式的執行流程是</p>
<ol class="arabic simple"><li>將 epub 檔解壓縮到暫存資料夾</li>
<li>將 暫存資料夾裡面的所有檔案從 UTF-8 簡體 轉成 UTF-8 繁體</li>
<li>將資料夾壓縮，並且順便將檔名轉成繁體</li>
</ol><p>簡體轉繁體的程式碼是使用 <a class="reference external" href="http://www.mandarintools.com/zhcode.html">zhcode</a></p>
<p>整個步驟就只有這樣而已。</p>
</div>
<div class="section" id="id5">
<h3>使用方式</h3>
<p>整個程式的資料夾結構如下</p>
<pre class="literal-block">
/EPUBConverter
  |---Source
  |---Result
  |---Converter.bat
  |---Converter.jar
  |---hcutf8.txt
</pre>
<p>hcutf8.txt 是個對應表，他列出了簡體字跟繁體字的對應。所以如果想自行更改轉換字的話，可以修改這個檔案（應該可以）。
要使用只要執行 Converter.bat 就會自動將 Source 資料夾底下 <em>所有</em> 的檔案，轉換到 Result 資料夾底下，就這樣而已了。</p>
</div>
</div></div>
        
    <p>
        <a href="../posts/epubconverter.html#disqus_thread" data-disqus-identifier="cache\posts\2012-05-11-epubconverter.html">Comments</a>

        </p></div>
        <div class="postbox">
        <h1><a href="../posts/scala-orm-note.html">Scala ORM 工具筆記-Circumflex與ActiveJDBC</a>
        <small>  
             Posted: 2012-02-07 13:44
        </small></h1>
        <hr><div><div class="section" id="circumflex">
<h2>Circumflex</h2>
<div class="section" id="prepare">
<h3>Prepare</h3>
<p><a class="reference external" href="http://circumflex.ru/">Circumflex</a> 我是使用SBT連到Maven repository去載入他所有的Library。</p>
<dl class="docutils"><dt>載入的項目有</dt>
<dd><ul class="first last simple"><li>circumflex-orm-2.1.jar</li>
<li>circumflex-core-2.1.jar</li>
<li>commons-io-2.0.1</li>
<li>circumflex-cache-2.1.jar</li>
<li>slf4j-api-1.6.1</li>
<li>ehcache-core-2.4.4</li>
<li>jta-1.1.jar</li>
<li>c3p0-0.9.1.1.jar</li>
</ul></dd>
</dl><p>Circumflex全部載入約2.3MB左右，比其他LightWeight的Library要大的很多。</p>
</div>
<div class="section" id="create-table">
<h3>Create Table</h3>
<p>Circumflex的設計，主要是在是產生一個對應的資料物件，例如</p>
<pre class="code scala literal-block">
<span class="k">class</span> <span class="nc">Country</span> <span class="k">extends</span> <span class="nc">Record</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Country</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">code</span> <span class="k">=</span> <span class="s">"code"</span><span class="o">.</span><span class="nc">VARCHAR</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="nc">NOT_NULL</span><span class="o">.</span><span class="nc">DEFAULT</span><span class="o">(</span><span class="s">"'ch'"</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">name</span> <span class="k">=</span> <span class="s">"name"</span><span class="o">.</span><span class="nc">TEXT</span><span class="o">.</span><span class="nc">NOT_NULL</span>

  <span class="k">def</span> <span class="n">cities</span> <span class="k">=</span> <span class="n">inverseMany</span><span class="o">(</span><span class="nc">City</span><span class="o">.</span><span class="n">country</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">relation</span> <span class="k">=</span> <span class="nc">Country</span>
  <span class="k">def</span> <span class="nc">PRIMARY_KEY</span> <span class="k">=</span> <span class="n">code</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Country</span> <span class="k">extends</span> <span class="nc">Country</span> <span class="k">with</span> <span class="nc">Table</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Country</span><span class="o">]</span>
</pre>
<p>其中class與object兩者皆為必要的，但是在object Country的繼承型態宣告，連續繼承了Country與Table。
我覺得這部分會讓人有點困惑為何需要如此處理，但是這還是其次的。</p>
<p>在建立好資料物件之後，就可以利用此資料物件Create Table。</p>
<pre class="code scala literal-block">
<span class="k">val</span> <span class="n">ddl</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">DDLUnit</span><span class="o">(</span><span class="nc">Country</span><span class="o">)</span>
<span class="n">ddl</span><span class="o">.</span><span class="nc">CREATE</span>
<span class="n">ddl</span><span class="o">.</span><span class="nc">DROP</span>
<span class="n">ddl</span><span class="o">.</span><span class="nc">DROP_CREATE</span>
</pre>
<p>建立Table的部分非常方便。</p>
</div>
<div class="section" id="association">
<h3>讓我不會用的Association</h3>
<p>關聯式資料庫的架構非常常見，不管是One-to-One、One-to-Many等結構，我的小程式也很需要這方面功能的支持。
Circumflex的設定方式是將變數宣告成inverseMany或inverseOne的型態，他目前沒有支援Many-to-Many。</p>
<pre class="code scala literal-block">
<span class="k">class</span> <span class="nc">City</span> <span class="k">extends</span> <span class="nc">Record</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">City</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">country</span> <span class="k">=</span> <span class="s">"country_code"</span><span class="o">.</span><span class="nc">TEXT</span><span class="o">.</span><span class="nc">REFERENCES</span><span class="o">(</span><span class="nc">Country</span><span class="o">).</span><span class="nc">ON_DELETE</span><span class="o">(</span><span class="nc">CASCADE</span><span class="o">).</span><span class="nc">ON_UPDATE</span><span class="o">(</span><span class="nc">NO_ACTION</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Country</span> <span class="k">extends</span> <span class="nc">Record</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Country</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">cities</span> <span class="k">=</span> <span class="n">inverseMany</span><span class="o">(</span><span class="nc">City</span><span class="o">.</span><span class="n">country</span><span class="o">)</span>
<span class="o">}</span>
</pre>
<p>inverseMany會回傳一個inverseMany的物件，呼叫inverseMany.get之後可以得到一個seq的物件。這個物件是immutable的
，因此你沒有辦法插入資料。所以我想像中的使用方式是Country與City兩個都是各自去儲存的，
然後可以透過Country.cities()取得所有有關的City，相對的City.country()則可以查詢取得對應的Country。
但是這比較不符合我想要的方式，我還是希望那個Collection是可以讓我CRUD的，並且在儲存Country的時候可以一併更新City。</p>
</div>
</div>
<div class="section" id="activejdbc">
<h2>ActiveJDBC</h2>
<div class="section" id="id2">
<h3>Prepare</h3>
<p><a class="reference external" href="http://code.google.com/p/activejdbc/">activejdbc</a> 所需要的Library比較多一點，因此建議使用Maven去匯入，或者使用SBT將會減少很多麻煩。
匯入的方式可以參考 <a class="reference external" href="http://code.google.com/p/activejdbc/wiki/GettingStarted">Getting Start</a> 。
我在這邊也簡單列出一下使用activejdbc有匯入的Library</p>
<dl class="docutils"><dt>activejdbc 所需要的 Library</dt>
<dd><ul class="first last simple"><li>activejdbc-1.2-SNAPSHOT.jar</li>
<li>slf4j-api-1.5.10</li>
<li>javalite-common-1.2-SNAPSHOT.jar</li>
<li>ehcache-core-2.4.5</li>
</ul></dd>
</dl><p>上面這幾個Library中，以ehcache最大約 9xx KB</p>
</div>
<div class="section" id="id3">
<h3>Create Table</h3>
<p>activejdbc並沒有支援Create Table等動作，因此這些動作需要自己撰寫SQL來處理。</p>
</div>
<div class="section" id="write-model">
<h3>Write Model</h3>
<p>寫Model的時候最主要要注意物件的名稱，如果你的Table名稱是"employees"這種複數名詞，那麼你的Model名稱就應該為"employee"。
activejdbc會自動對應複數名詞的Table與單數名詞的Model。(不知道對於es之類的這種變化他是不是也可以處理)。
當然如果有需要的話，也可以使用**@Table**來指定Table名稱。</p>
<pre class="code scala literal-block">
<span class="nd">@Table</span><span class="o">(</span><span class="s">"TABLE_NAME"</span><span class="o">)</span>
<span class="k">class</span> <span class="nc">employe</span> <span class="k">extends</span> <span class="nc">Model</span><span class="o">{}</span>
</pre>
<p>P.S 幹悲劇了，由於activejdbc裡面的Model的set有三種傳值方式。</p>
<pre class="code scala literal-block">
<span class="n">set</span><span class="o">(</span><span class="nc">Object</span><span class="o">...</span> <span class="n">namesAndValues</span><span class="o">)</span>
<span class="n">set</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">attributeNames</span><span class="o">,</span><span class="nc">Object</span><span class="o">[]</span> <span class="n">values</span><span class="o">)</span>
<span class="n">set</span><span class="o">(</span><span class="nc">String</span> <span class="n">attribute</span><span class="o">,</span><span class="nc">Object</span> <span class="n">value</span><span class="o">)</span>
</pre>
<p>這種寫法Scala在使用的時候會認為是**ambiguous reference to overloaded definition**
因為當我們使用</p>
<pre class="code scala literal-block">
<span class="n">employe</span><span class="o">.</span><span class="n">set</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span><span class="s">"John"</span><span class="o">)</span>
</pre>
<p>的時候，Scala會覺得符合set(Object... namesAndValues)與set(String attribute,Object Value)。
不過我覺得這方面Scala蠻合理的，去查了一下似乎也傾向不會去修改這個。(抱頭 Orz)
如果修改成使用</p>
<pre class="code scala literal-block">
<span class="n">set</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">attributeNames</span><span class="o">,</span><span class="nc">Object</span><span class="o">[]</span> <span class="n">values</span><span class="o">)</span>
</pre>
<p>就不會有問題了 WTF
另外一個解決方式就是使用setString等指定型態的設定方式，我想這應該是個不錯的解法</p>
<pre class="code scala literal-block">
<span class="n">employe</span><span class="o">.</span><span class="n">setString</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span><span class="s">"John"</span><span class="o">)</span>
</pre>
</div>
<div class="section" id="id4">
<h3>放棄activejdbc</h3>
<p>他還有一個instrumentation的步驟，這個步驟我覺得影響太多了，不適合拿來跟Scala一起合用。</p>
</div>
</div></div>
        
    <p>
        <a href="../posts/scala-orm-note.html#disqus_thread" data-disqus-identifier="cache\posts\2011-02-07-scala-orm-libraries.html">Comments</a>

        </p></div>
    
<div>
<ul class="pager"><li class="next">
        <a href="scala-1.html">Older posts →</a>
    </li>
</ul></div>

    
       <script type="text/javascript">var disqus_shortname="nikolademo";(function(){var a=document.createElement("script");a.async=true;a.type="text/javascript";a.src="http://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)}());</script></div>
    </div> 
    <!--End of body content-->
</div>
<div class="footerbox">
    Contents © 2013 <a href="mailto:">Swind</a> - Powered by <a href="http://nikola.ralsina.com.ar">Nikola</a>
</div>

    <!-- Social buttons -->
    <div id="addthisbox" class="addthis_toolbox addthis_peekaboo_style addthis_default_style addthis_label_style addthis_32x32_style">
    <a class="addthis_button_more">Share</a>
    <ul><li><a class="addthis_button_facebook"></a></li>
    <li><a class="addthis_button_google_plusone_share"></a></li>
    <li><a class="addthis_button_linkedin"></a></li>
    <li><a class="addthis_button_twitter"></a></li>
    </ul></div>
    <script type="text/javascript" src="http://s7.addthis.com/js/300/addthis_widget.js#pubid=ra-4f7088a56bb93798"></script><!-- End of social buttons --><script type="text/javascript">jQuery("a.image-reference").colorbox({rel:"gal",maxWidth:"80%",maxHeight:"80%",scalePhotos:true});</script></body></html>